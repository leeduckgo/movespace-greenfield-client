/// <reference types="long" />
import { Coin, CoinSDKType } from "../../cosmos/base/v1beta1/coin";
import { Status, Description, DescriptionSDKType } from "./types";
import { Long } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.sp";
/** EventCreateStorageProvider is emitted when there is a storage provider created */
export interface EventCreateStorageProvider {
    /** sp_id defines the identifier of storage provider which generated on-chain */
    spId: number;
    /** sp_address is the operator address of the storage provider */
    spAddress: string;
    /** funding_address is the funding account address of the storage provider */
    fundingAddress: string;
    /** seal_address is the account address for SealObject Tx */
    sealAddress: string;
    /** approval_address is the account address for approve create bucket/object signature */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose */
    gcAddress: string;
    /** maintenance_address defines one of the storage provider's accounts which is used for testing while in maintenance mode */
    maintenanceAddress: string;
    /** endpoint is the domain name address used by SP to provide storage services */
    endpoint: string;
    /** total_deposit is the token coin that the storage provider deposit to the storage module */
    totalDeposit: Coin;
    /** status defines the status of the storage provider */
    status: Status;
    /** description defines the description terms for the storage provider */
    description: Description;
    /** bls_key defines the bls pub key owned by storage provider used when sealing object and completing migration */
    blsKey: string;
}
/** EventCreateStorageProvider is emitted when there is a storage provider created */
export interface EventCreateStorageProviderSDKType {
    sp_id: number;
    sp_address: string;
    funding_address: string;
    seal_address: string;
    approval_address: string;
    gc_address: string;
    maintenance_address: string;
    endpoint: string;
    total_deposit: CoinSDKType;
    status: Status;
    description: DescriptionSDKType;
    bls_key: string;
}
/** EventEditStorageProvider is emitted when SP's metadata is edited. */
export interface EventEditStorageProvider {
    /** sp_id defines the identifier of storage provider which generated on-chain */
    spId: number;
    /** sp_address is the operator address of the storage provider */
    spAddress: string;
    /** endpoint is the service endpoint of the storage provider */
    endpoint: string;
    /** description defines the description terms for the storage provider */
    description: Description;
    /** seal_address is the account address for SealObject Tx */
    sealAddress: string;
    /** approval_address is the account address for approve create bucket/object signature */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose */
    gcAddress: string;
    /** maintenance_address defines one of the storage provider's accounts which is used for testing while in maintenance mode */
    maintenanceAddress: string;
    /** bls_key defines the bls pub key owned by storage provider used when sealing object */
    blsKey: string;
}
/** EventEditStorageProvider is emitted when SP's metadata is edited. */
export interface EventEditStorageProviderSDKType {
    sp_id: number;
    sp_address: string;
    endpoint: string;
    description: DescriptionSDKType;
    seal_address: string;
    approval_address: string;
    gc_address: string;
    maintenance_address: string;
    bls_key: string;
}
/** EventDeposit is emitted when sp deposit tokens. */
export interface EventDeposit {
    /** funding_address is the funding account address of the storage provider */
    fundingAddress: string;
    /** deposit is the token coin deposited this message */
    deposit: string;
    /** total_deposit is the total token coins this storage provider deposited */
    totalDeposit: string;
}
/** EventDeposit is emitted when sp deposit tokens. */
export interface EventDepositSDKType {
    funding_address: string;
    deposit: string;
    total_deposit: string;
}
export interface EventSpStoragePriceUpdate {
    /** sp id */
    spId: number;
    /** update time, in unix timestamp */
    updateTimeSec: Long;
    /** read price, in bnb wei per charge byte */
    readPrice: string;
    /** free read quota, in byte */
    freeReadQuota: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
}
export interface EventSpStoragePriceUpdateSDKType {
    sp_id: number;
    update_time_sec: Long;
    read_price: string;
    free_read_quota: Long;
    store_price: string;
}
export interface EventGlobalSpStorePriceUpdate {
    /** update time, in unix timestamp */
    updateTimeSec: Long;
    /** read price, in bnb wei per charge byte */
    readPrice: string;
    /** primary store price, in bnb wei per charge byte */
    primaryStorePrice: string;
    /** secondary store price, in bnb wei per charge byte */
    secondaryStorePrice: string;
}
export interface EventGlobalSpStorePriceUpdateSDKType {
    update_time_sec: Long;
    read_price: string;
    primary_store_price: string;
    secondary_store_price: string;
}
/** EventUpdateStorageProviderStatus is emitted when the SP update its status successfully */
export interface EventUpdateStorageProviderStatus {
    /** sp_id defines the identifier of storage provider which generated on-chain */
    spId: number;
    /** sp_address is the operator address of the storage provider */
    spAddress: string;
    /** pre status */
    preStatus: string;
    /** new status */
    newStatus: string;
}
/** EventUpdateStorageProviderStatus is emitted when the SP update its status successfully */
export interface EventUpdateStorageProviderStatusSDKType {
    sp_id: number;
    sp_address: string;
    pre_status: string;
    new_status: string;
}
export declare const EventCreateStorageProvider: {
    encode(message: EventCreateStorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateStorageProvider;
    fromJSON(object: any): EventCreateStorageProvider;
    toJSON(message: EventCreateStorageProvider): unknown;
    fromPartial<I extends {
        spId?: number;
        spAddress?: string;
        fundingAddress?: string;
        sealAddress?: string;
        approvalAddress?: string;
        gcAddress?: string;
        maintenanceAddress?: string;
        endpoint?: string;
        totalDeposit?: {
            denom?: string;
            amount?: string;
        };
        status?: Status;
        description?: {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        };
        blsKey?: string;
    } & {
        spId?: number;
        spAddress?: string;
        fundingAddress?: string;
        sealAddress?: string;
        approvalAddress?: string;
        gcAddress?: string;
        maintenanceAddress?: string;
        endpoint?: string;
        totalDeposit?: {
            denom?: string;
            amount?: string;
        } & {
            denom?: string;
            amount?: string;
        } & Record<Exclude<keyof I["totalDeposit"], keyof Coin>, never>;
        status?: Status;
        description?: {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        } & {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>;
        blsKey?: string;
    } & Record<Exclude<keyof I, keyof EventCreateStorageProvider>, never>>(object: I): EventCreateStorageProvider;
    fromSDK(object: EventCreateStorageProviderSDKType): EventCreateStorageProvider;
    toSDK(message: EventCreateStorageProvider): EventCreateStorageProviderSDKType;
};
export declare const EventEditStorageProvider: {
    encode(message: EventEditStorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventEditStorageProvider;
    fromJSON(object: any): EventEditStorageProvider;
    toJSON(message: EventEditStorageProvider): unknown;
    fromPartial<I extends {
        spId?: number;
        spAddress?: string;
        endpoint?: string;
        description?: {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        };
        sealAddress?: string;
        approvalAddress?: string;
        gcAddress?: string;
        maintenanceAddress?: string;
        blsKey?: string;
    } & {
        spId?: number;
        spAddress?: string;
        endpoint?: string;
        description?: {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        } & {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>;
        sealAddress?: string;
        approvalAddress?: string;
        gcAddress?: string;
        maintenanceAddress?: string;
        blsKey?: string;
    } & Record<Exclude<keyof I, keyof EventEditStorageProvider>, never>>(object: I): EventEditStorageProvider;
    fromSDK(object: EventEditStorageProviderSDKType): EventEditStorageProvider;
    toSDK(message: EventEditStorageProvider): EventEditStorageProviderSDKType;
};
export declare const EventDeposit: {
    encode(message: EventDeposit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeposit;
    fromJSON(object: any): EventDeposit;
    toJSON(message: EventDeposit): unknown;
    fromPartial<I extends {
        fundingAddress?: string;
        deposit?: string;
        totalDeposit?: string;
    } & {
        fundingAddress?: string;
        deposit?: string;
        totalDeposit?: string;
    } & Record<Exclude<keyof I, keyof EventDeposit>, never>>(object: I): EventDeposit;
    fromSDK(object: EventDepositSDKType): EventDeposit;
    toSDK(message: EventDeposit): EventDepositSDKType;
};
export declare const EventSpStoragePriceUpdate: {
    encode(message: EventSpStoragePriceUpdate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSpStoragePriceUpdate;
    fromJSON(object: any): EventSpStoragePriceUpdate;
    toJSON(message: EventSpStoragePriceUpdate): unknown;
    fromPartial<I extends {
        spId?: number;
        updateTimeSec?: string | number | Long.Long;
        readPrice?: string;
        freeReadQuota?: string | number | Long.Long;
        storePrice?: string;
    } & {
        spId?: number;
        updateTimeSec?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["updateTimeSec"], keyof Long.Long>, never>);
        readPrice?: string;
        freeReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["freeReadQuota"], keyof Long.Long>, never>);
        storePrice?: string;
    } & Record<Exclude<keyof I, keyof EventSpStoragePriceUpdate>, never>>(object: I): EventSpStoragePriceUpdate;
    fromSDK(object: EventSpStoragePriceUpdateSDKType): EventSpStoragePriceUpdate;
    toSDK(message: EventSpStoragePriceUpdate): EventSpStoragePriceUpdateSDKType;
};
export declare const EventGlobalSpStorePriceUpdate: {
    encode(message: EventGlobalSpStorePriceUpdate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventGlobalSpStorePriceUpdate;
    fromJSON(object: any): EventGlobalSpStorePriceUpdate;
    toJSON(message: EventGlobalSpStorePriceUpdate): unknown;
    fromPartial<I extends {
        updateTimeSec?: string | number | Long.Long;
        readPrice?: string;
        primaryStorePrice?: string;
        secondaryStorePrice?: string;
    } & {
        updateTimeSec?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["updateTimeSec"], keyof Long.Long>, never>);
        readPrice?: string;
        primaryStorePrice?: string;
        secondaryStorePrice?: string;
    } & Record<Exclude<keyof I, keyof EventGlobalSpStorePriceUpdate>, never>>(object: I): EventGlobalSpStorePriceUpdate;
    fromSDK(object: EventGlobalSpStorePriceUpdateSDKType): EventGlobalSpStorePriceUpdate;
    toSDK(message: EventGlobalSpStorePriceUpdate): EventGlobalSpStorePriceUpdateSDKType;
};
export declare const EventUpdateStorageProviderStatus: {
    encode(message: EventUpdateStorageProviderStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateStorageProviderStatus;
    fromJSON(object: any): EventUpdateStorageProviderStatus;
    toJSON(message: EventUpdateStorageProviderStatus): unknown;
    fromPartial<I extends {
        spId?: number;
        spAddress?: string;
        preStatus?: string;
        newStatus?: string;
    } & {
        spId?: number;
        spAddress?: string;
        preStatus?: string;
        newStatus?: string;
    } & Record<Exclude<keyof I, keyof EventUpdateStorageProviderStatus>, never>>(object: I): EventUpdateStorageProviderStatus;
    fromSDK(object: EventUpdateStorageProviderStatusSDKType): EventUpdateStorageProviderStatus;
    toSDK(message: EventUpdateStorageProviderStatus): EventUpdateStorageProviderStatusSDKType;
};

/// <reference types="long" />
import { VisibilityType, SourceType, BucketStatus, LocalVirtualGroup, LocalVirtualGroupSDKType, ObjectStatus, RedundancyType } from "./common";
import { Long } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
export interface BucketInfo {
    /** owner is the account address of bucket creator, it is also the bucket owner. */
    owner: string;
    /** bucket_name is a globally unique name of bucket */
    bucketName: string;
    /** visibility defines the highest permissions for bucket. When a bucket is public, everyone can get storage objects in it. */
    visibility: VisibilityType;
    /** id is the unique identification for bucket. */
    id: string;
    /** source_type defines which chain the user should send the bucket management transactions to */
    sourceType: SourceType;
    /** create_at define the block timestamp when the bucket created. */
    createAt: Long;
    /** payment_address is the address of the payment account */
    paymentAddress: string;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    globalVirtualGroupFamilyId: number;
    /**
     * charged_read_quota defines the traffic quota for read in bytes per month.
     * The available read data for each user is the sum of the free read data provided by SP and
     * the ChargeReadQuota specified here.
     */
    chargedReadQuota: Long;
    /** bucket_status define the status of the bucket. */
    bucketStatus: BucketStatus;
}
export interface BucketInfoSDKType {
    owner: string;
    bucket_name: string;
    visibility: VisibilityType;
    id: string;
    source_type: SourceType;
    create_at: Long;
    payment_address: string;
    global_virtual_group_family_id: number;
    charged_read_quota: Long;
    bucket_status: BucketStatus;
}
export interface InternalBucketInfo {
    /** the time of the payment price, used to calculate the charge rate of the bucket */
    priceTime: Long;
    /** the total size of the objects in the bucket, used to calculate the charge rate of the bucket */
    totalChargeSize: Long;
    /** local_virtual_groups contains all the lvg of this bucket. */
    localVirtualGroups: LocalVirtualGroup[];
    /** next_local_virtual_group_id store the next id used by local virtual group */
    nextLocalVirtualGroupId: number;
}
export interface InternalBucketInfoSDKType {
    price_time: Long;
    total_charge_size: Long;
    local_virtual_groups: LocalVirtualGroupSDKType[];
    next_local_virtual_group_id: number;
}
export interface ObjectInfo {
    /** owner is the object owner */
    owner: string;
    /** creator is the address of the uploader, it always be same as owner address */
    creator: string;
    /** bucket_name is the name of the bucket */
    bucketName: string;
    /** object_name is the name of object */
    objectName: string;
    /** id is the unique identifier of object */
    id: string;
    localVirtualGroupId: number;
    /** payloadSize is the total size of the object payload */
    payloadSize: Long;
    /** visibility defines the highest permissions for object. When an object is public, everyone can access it. */
    visibility: VisibilityType;
    /** content_type define the format of the object which should be a standard MIME type. */
    contentType: string;
    /** create_at define the block timestamp when the object is created */
    createAt: Long;
    /** object_status define the upload status of the object. */
    objectStatus: ObjectStatus;
    /** redundancy_type define the type of the redundancy which can be multi-replication or EC. */
    redundancyType: RedundancyType;
    /** source_type define the source of the object. */
    sourceType: SourceType;
    /**
     * checksums define the root hash of the pieces which stored in a SP.
     * add omit tag to omit the field when converting to NFT metadata
     */
    checksums: Uint8Array[];
}
export interface ObjectInfoSDKType {
    owner: string;
    creator: string;
    bucket_name: string;
    object_name: string;
    id: string;
    local_virtual_group_id: number;
    payload_size: Long;
    visibility: VisibilityType;
    content_type: string;
    create_at: Long;
    object_status: ObjectStatus;
    redundancy_type: RedundancyType;
    source_type: SourceType;
    checksums: Uint8Array[];
}
export interface GroupInfo {
    /** owner is the owner of the group. It can not changed once it created. */
    owner: string;
    /** group_name is the name of group which is unique under an account. */
    groupName: string;
    /** source_type */
    sourceType: SourceType;
    /** id is the unique identifier of group */
    id: string;
    /** extra is used to store extra info for the group */
    extra: string;
}
export interface GroupInfoSDKType {
    owner: string;
    group_name: string;
    source_type: SourceType;
    id: string;
    extra: string;
}
export interface Trait {
    traitType: string;
    value: string;
}
export interface TraitSDKType {
    trait_type: string;
    value: string;
}
export interface BucketMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of bucket NFT */
    bucketName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface BucketMetaDataSDKType {
    description: string;
    external_url: string;
    bucket_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface ObjectMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of object NFT */
    objectName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface ObjectMetaDataSDKType {
    description: string;
    external_url: string;
    object_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface GroupMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of group NFT */
    groupName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface GroupMetaDataSDKType {
    description: string;
    external_url: string;
    group_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface Ids {
    /** ids of the objects or buckets */
    id: string[];
}
export interface IdsSDKType {
    id: string[];
}
export interface DeleteInfo {
    bucketIds: Ids;
    objectIds: Ids;
    groupIds: Ids;
}
export interface DeleteInfoSDKType {
    bucket_ids: IdsSDKType;
    object_ids: IdsSDKType;
    group_ids: IdsSDKType;
}
export interface MigrationBucketInfo {
    srcSpId: number;
    srcGlobalVirtualGroupFamilyId: number;
    dstSpId: number;
    /** id is the unique identifier of bucket */
    bucketId: string;
}
export interface MigrationBucketInfoSDKType {
    src_sp_id: number;
    src_global_virtual_group_family_id: number;
    dst_sp_id: number;
    bucket_id: string;
}
export declare const BucketInfo: {
    encode(message: BucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BucketInfo;
    fromJSON(object: any): BucketInfo;
    toJSON(message: BucketInfo): unknown;
    fromPartial<I extends {
        owner?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        id?: string;
        sourceType?: SourceType;
        createAt?: string | number | Long.Long;
        paymentAddress?: string;
        globalVirtualGroupFamilyId?: number;
        chargedReadQuota?: string | number | Long.Long;
        bucketStatus?: BucketStatus;
    } & {
        owner?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        id?: string;
        sourceType?: SourceType;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        paymentAddress?: string;
        globalVirtualGroupFamilyId?: number;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>);
        bucketStatus?: BucketStatus;
    } & Record<Exclude<keyof I, keyof BucketInfo>, never>>(object: I): BucketInfo;
    fromSDK(object: BucketInfoSDKType): BucketInfo;
    toSDK(message: BucketInfo): BucketInfoSDKType;
};
export declare const InternalBucketInfo: {
    encode(message: InternalBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InternalBucketInfo;
    fromJSON(object: any): InternalBucketInfo;
    toJSON(message: InternalBucketInfo): unknown;
    fromPartial<I extends {
        priceTime?: string | number | Long.Long;
        totalChargeSize?: string | number | Long.Long;
        localVirtualGroups?: {
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
        }[];
        nextLocalVirtualGroupId?: number;
    } & {
        priceTime?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["priceTime"], keyof Long.Long>, never>);
        totalChargeSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["totalChargeSize"], keyof Long.Long>, never>);
        localVirtualGroups?: {
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
        }[] & ({
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
        } & {
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["localVirtualGroups"][number]["storedSize"], keyof Long.Long>, never>);
            totalChargeSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["localVirtualGroups"][number]["totalChargeSize"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["localVirtualGroups"][number], keyof LocalVirtualGroup>, never>)[] & Record<Exclude<keyof I["localVirtualGroups"], keyof {
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
        }[]>, never>;
        nextLocalVirtualGroupId?: number;
    } & Record<Exclude<keyof I, keyof InternalBucketInfo>, never>>(object: I): InternalBucketInfo;
    fromSDK(object: InternalBucketInfoSDKType): InternalBucketInfo;
    toSDK(message: InternalBucketInfo): InternalBucketInfoSDKType;
};
export declare const ObjectInfo: {
    encode(message: ObjectInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ObjectInfo;
    fromJSON(object: any): ObjectInfo;
    toJSON(message: ObjectInfo): unknown;
    fromPartial<I extends {
        owner?: string;
        creator?: string;
        bucketName?: string;
        objectName?: string;
        id?: string;
        localVirtualGroupId?: number;
        payloadSize?: string | number | Long.Long;
        visibility?: VisibilityType;
        contentType?: string;
        createAt?: string | number | Long.Long;
        objectStatus?: ObjectStatus;
        redundancyType?: RedundancyType;
        sourceType?: SourceType;
        checksums?: Uint8Array[];
    } & {
        owner?: string;
        creator?: string;
        bucketName?: string;
        objectName?: string;
        id?: string;
        localVirtualGroupId?: number;
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>);
        visibility?: VisibilityType;
        contentType?: string;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        objectStatus?: ObjectStatus;
        redundancyType?: RedundancyType;
        sourceType?: SourceType;
        checksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["checksums"], keyof Uint8Array[]>, never>;
    } & Record<Exclude<keyof I, keyof ObjectInfo>, never>>(object: I): ObjectInfo;
    fromSDK(object: ObjectInfoSDKType): ObjectInfo;
    toSDK(message: ObjectInfo): ObjectInfoSDKType;
};
export declare const GroupInfo: {
    encode(message: GroupInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GroupInfo;
    fromJSON(object: any): GroupInfo;
    toJSON(message: GroupInfo): unknown;
    fromPartial<I extends {
        owner?: string;
        groupName?: string;
        sourceType?: SourceType;
        id?: string;
        extra?: string;
    } & {
        owner?: string;
        groupName?: string;
        sourceType?: SourceType;
        id?: string;
        extra?: string;
    } & Record<Exclude<keyof I, keyof GroupInfo>, never>>(object: I): GroupInfo;
    fromSDK(object: GroupInfoSDKType): GroupInfo;
    toSDK(message: GroupInfo): GroupInfoSDKType;
};
export declare const Trait: {
    encode(message: Trait, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Trait;
    fromJSON(object: any): Trait;
    toJSON(message: Trait): unknown;
    fromPartial<I extends {
        traitType?: string;
        value?: string;
    } & {
        traitType?: string;
        value?: string;
    } & Record<Exclude<keyof I, keyof Trait>, never>>(object: I): Trait;
    fromSDK(object: TraitSDKType): Trait;
    toSDK(message: Trait): TraitSDKType;
};
export declare const BucketMetaData: {
    encode(message: BucketMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BucketMetaData;
    fromJSON(object: any): BucketMetaData;
    toJSON(message: BucketMetaData): unknown;
    fromPartial<I extends {
        description?: string;
        externalUrl?: string;
        bucketName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[];
    } & {
        description?: string;
        externalUrl?: string;
        bucketName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[] & ({
            traitType?: string;
            value?: string;
        } & {
            traitType?: string;
            value?: string;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string;
            value?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof BucketMetaData>, never>>(object: I): BucketMetaData;
    fromSDK(object: BucketMetaDataSDKType): BucketMetaData;
    toSDK(message: BucketMetaData): BucketMetaDataSDKType;
};
export declare const ObjectMetaData: {
    encode(message: ObjectMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ObjectMetaData;
    fromJSON(object: any): ObjectMetaData;
    toJSON(message: ObjectMetaData): unknown;
    fromPartial<I extends {
        description?: string;
        externalUrl?: string;
        objectName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[];
    } & {
        description?: string;
        externalUrl?: string;
        objectName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[] & ({
            traitType?: string;
            value?: string;
        } & {
            traitType?: string;
            value?: string;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string;
            value?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof ObjectMetaData>, never>>(object: I): ObjectMetaData;
    fromSDK(object: ObjectMetaDataSDKType): ObjectMetaData;
    toSDK(message: ObjectMetaData): ObjectMetaDataSDKType;
};
export declare const GroupMetaData: {
    encode(message: GroupMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GroupMetaData;
    fromJSON(object: any): GroupMetaData;
    toJSON(message: GroupMetaData): unknown;
    fromPartial<I extends {
        description?: string;
        externalUrl?: string;
        groupName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[];
    } & {
        description?: string;
        externalUrl?: string;
        groupName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[] & ({
            traitType?: string;
            value?: string;
        } & {
            traitType?: string;
            value?: string;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string;
            value?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof GroupMetaData>, never>>(object: I): GroupMetaData;
    fromSDK(object: GroupMetaDataSDKType): GroupMetaData;
    toSDK(message: GroupMetaData): GroupMetaDataSDKType;
};
export declare const Ids: {
    encode(message: Ids, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Ids;
    fromJSON(object: any): Ids;
    toJSON(message: Ids): unknown;
    fromPartial<I extends {
        id?: string[];
    } & {
        id?: string[] & string[] & Record<Exclude<keyof I["id"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, "id">, never>>(object: I): Ids;
    fromSDK(object: IdsSDKType): Ids;
    toSDK(message: Ids): IdsSDKType;
};
export declare const DeleteInfo: {
    encode(message: DeleteInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteInfo;
    fromJSON(object: any): DeleteInfo;
    toJSON(message: DeleteInfo): unknown;
    fromPartial<I extends {
        bucketIds?: {
            id?: string[];
        };
        objectIds?: {
            id?: string[];
        };
        groupIds?: {
            id?: string[];
        };
    } & {
        bucketIds?: {
            id?: string[];
        } & {
            id?: string[] & string[] & Record<Exclude<keyof I["bucketIds"]["id"], keyof string[]>, never>;
        } & Record<Exclude<keyof I["bucketIds"], "id">, never>;
        objectIds?: {
            id?: string[];
        } & {
            id?: string[] & string[] & Record<Exclude<keyof I["objectIds"]["id"], keyof string[]>, never>;
        } & Record<Exclude<keyof I["objectIds"], "id">, never>;
        groupIds?: {
            id?: string[];
        } & {
            id?: string[] & string[] & Record<Exclude<keyof I["groupIds"]["id"], keyof string[]>, never>;
        } & Record<Exclude<keyof I["groupIds"], "id">, never>;
    } & Record<Exclude<keyof I, keyof DeleteInfo>, never>>(object: I): DeleteInfo;
    fromSDK(object: DeleteInfoSDKType): DeleteInfo;
    toSDK(message: DeleteInfo): DeleteInfoSDKType;
};
export declare const MigrationBucketInfo: {
    encode(message: MigrationBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MigrationBucketInfo;
    fromJSON(object: any): MigrationBucketInfo;
    toJSON(message: MigrationBucketInfo): unknown;
    fromPartial<I extends {
        srcSpId?: number;
        srcGlobalVirtualGroupFamilyId?: number;
        dstSpId?: number;
        bucketId?: string;
    } & {
        srcSpId?: number;
        srcGlobalVirtualGroupFamilyId?: number;
        dstSpId?: number;
        bucketId?: string;
    } & Record<Exclude<keyof I, keyof MigrationBucketInfo>, never>>(object: I): MigrationBucketInfo;
    fromSDK(object: MigrationBucketInfoSDKType): MigrationBucketInfo;
    toSDK(message: MigrationBucketInfo): MigrationBucketInfoSDKType;
};

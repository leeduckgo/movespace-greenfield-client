/// <reference types="long" />
import { Description, DescriptionSDKType, Status } from "./types";
import { Coin, CoinSDKType } from "../../cosmos/base/v1beta1/coin";
import { Params, ParamsSDKType } from "./params";
import { Long, Rpc } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.sp";
/** MsgCreateStorageProvider defines message for creating a new storage provider. */
export interface MsgCreateStorageProvider {
    /** creator is the msg signer */
    creator: string;
    /** description defines the description terms for the storage provider. */
    description: Description;
    /** sp_address defines the address of the sp's operator; It also is the unqiue index key of sp. */
    spAddress: string;
    /** fund_address is the account address of the storage provider for deposit, remuneration. */
    fundingAddress: string;
    /** seal_address is the account address of the storage provider for sealObject */
    sealAddress: string;
    /** approval_address is the account address of the storage provider for ack CreateBucket/Object. */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose. */
    gcAddress: string;
    /** maintenance_address defines one of the storage provider's accounts which is used for testing while in maintenance mode */
    maintenanceAddress: string;
    /** endpoint is the service address of the storage provider */
    endpoint: string;
    /** deposit define the deposit token */
    deposit: Coin;
    /** read price, in bnb wei per charge byte */
    readPrice: string;
    /** free read quota, in byte */
    freeReadQuota: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
    /** bls_key defines the bls pub key of the Storage provider for sealing object */
    blsKey: string;
    blsProof: string;
}
/** MsgCreateStorageProvider defines message for creating a new storage provider. */
export interface MsgCreateStorageProviderSDKType {
    creator: string;
    description: DescriptionSDKType;
    sp_address: string;
    funding_address: string;
    seal_address: string;
    approval_address: string;
    gc_address: string;
    maintenance_address: string;
    endpoint: string;
    deposit: CoinSDKType;
    read_price: string;
    free_read_quota: Long;
    store_price: string;
    bls_key: string;
    bls_proof: string;
}
/** MsgCreateStorageProviderResponse defines the Msg/CreateStorageProvider response type. */
export interface MsgCreateStorageProviderResponse {
}
/** MsgCreateStorageProviderResponse defines the Msg/CreateStorageProvider response type. */
export interface MsgCreateStorageProviderResponseSDKType {
}
/** MsgDeposit defines a SDK message for deposit token for sp. */
export interface MsgDeposit {
    /** creator is the msg signer, it should be sp's fund address */
    creator: string;
    /** sp_address is the operator address of sp */
    spAddress: string;
    /** deposit is a mount of token which used to deposit for SP */
    deposit: Coin;
}
/** MsgDeposit defines a SDK message for deposit token for sp. */
export interface MsgDepositSDKType {
    creator: string;
    sp_address: string;
    deposit: CoinSDKType;
}
/** MsgDepositResponse defines the Msg/Deposit response type. */
export interface MsgDepositResponse {
}
/** MsgDepositResponse defines the Msg/Deposit response type. */
export interface MsgDepositResponseSDKType {
}
/**
 * MsgEditStorageProvider defines a SDK message for editing an existing sp.
 * TODO: use sp id to edit the storage provider.
 */
export interface MsgEditStorageProvider {
    spAddress: string;
    endpoint: string;
    description: Description;
    /** seal_address is the account address of the storage provider for sealObject */
    sealAddress: string;
    /** approval_address is the account address of the storage provider for ack CreateBucket/Object */
    approvalAddress: string;
    /** gc_address defines one of the storage provider's accounts which is used for gc purpose */
    gcAddress: string;
    /** maintenance_address defines one of the storage provider's accounts which is used for testing while in maintenance mode */
    maintenanceAddress: string;
    /** bls_key defines the bls pub key of the Storage provider for sealing object */
    blsKey: string;
    blsProof: string;
}
/**
 * MsgEditStorageProvider defines a SDK message for editing an existing sp.
 * TODO: use sp id to edit the storage provider.
 */
export interface MsgEditStorageProviderSDKType {
    sp_address: string;
    endpoint: string;
    description: DescriptionSDKType;
    seal_address: string;
    approval_address: string;
    gc_address: string;
    maintenance_address: string;
    bls_key: string;
    bls_proof: string;
}
/** MsgEditStorageProviderResponse defines the Msg/EditStorageProvider response type. */
export interface MsgEditStorageProviderResponse {
}
/** MsgEditStorageProviderResponse defines the Msg/EditStorageProvider response type. */
export interface MsgEditStorageProviderResponseSDKType {
}
export interface MsgUpdateSpStoragePrice {
    /** sp address */
    spAddress: string;
    /** read price, in bnb wei per charge byte */
    readPrice: string;
    /** free read quota, in byte */
    freeReadQuota: Long;
    /** store price, in bnb wei per charge byte */
    storePrice: string;
}
export interface MsgUpdateSpStoragePriceSDKType {
    sp_address: string;
    read_price: string;
    free_read_quota: Long;
    store_price: string;
}
export interface MsgUpdateSpStoragePriceResponse {
}
export interface MsgUpdateSpStoragePriceResponseSDKType {
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
    /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
    authority: string;
    /**
     * params defines the x/sp parameters to update.
     *
     * NOTE: All parameters must be supplied.
     */
    params: Params;
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParamsSDKType {
    authority: string;
    params: ParamsSDKType;
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}
/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponseSDKType {
}
/** MsgUpdateStorageProviderStatus is used to update the status of a SP by itself */
export interface MsgUpdateStorageProviderStatus {
    /** sp_address defines the operator address */
    spAddress: string;
    /** status defines the desired status be update to. */
    status: Status;
    /** duration defines the time requested in desired status */
    duration: Long;
}
/** MsgUpdateStorageProviderStatus is used to update the status of a SP by itself */
export interface MsgUpdateStorageProviderStatusSDKType {
    sp_address: string;
    status: Status;
    duration: Long;
}
/** MsgUpdateStorageProviderStatusResponse defines the MsgUpdateStorageProviderStatus response type. */
export interface MsgUpdateStorageProviderStatusResponse {
}
/** MsgUpdateStorageProviderStatusResponse defines the MsgUpdateStorageProviderStatus response type. */
export interface MsgUpdateStorageProviderStatusResponseSDKType {
}
export declare const MsgCreateStorageProvider: {
    encode(message: MsgCreateStorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateStorageProvider;
    fromJSON(object: any): MsgCreateStorageProvider;
    toJSON(message: MsgCreateStorageProvider): unknown;
    fromPartial<I extends {
        creator?: string;
        description?: {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        };
        spAddress?: string;
        fundingAddress?: string;
        sealAddress?: string;
        approvalAddress?: string;
        gcAddress?: string;
        maintenanceAddress?: string;
        endpoint?: string;
        deposit?: {
            denom?: string;
            amount?: string;
        };
        readPrice?: string;
        freeReadQuota?: string | number | Long.Long;
        storePrice?: string;
        blsKey?: string;
        blsProof?: string;
    } & {
        creator?: string;
        description?: {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        } & {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>;
        spAddress?: string;
        fundingAddress?: string;
        sealAddress?: string;
        approvalAddress?: string;
        gcAddress?: string;
        maintenanceAddress?: string;
        endpoint?: string;
        deposit?: {
            denom?: string;
            amount?: string;
        } & {
            denom?: string;
            amount?: string;
        } & Record<Exclude<keyof I["deposit"], keyof Coin>, never>;
        readPrice?: string;
        freeReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["freeReadQuota"], keyof Long.Long>, never>);
        storePrice?: string;
        blsKey?: string;
        blsProof?: string;
    } & Record<Exclude<keyof I, keyof MsgCreateStorageProvider>, never>>(object: I): MsgCreateStorageProvider;
    fromSDK(object: MsgCreateStorageProviderSDKType): MsgCreateStorageProvider;
    toSDK(message: MsgCreateStorageProvider): MsgCreateStorageProviderSDKType;
};
export declare const MsgCreateStorageProviderResponse: {
    encode(_: MsgCreateStorageProviderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateStorageProviderResponse;
    fromJSON(_: any): MsgCreateStorageProviderResponse;
    toJSON(_: MsgCreateStorageProviderResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgCreateStorageProviderResponse;
    fromSDK(_: MsgCreateStorageProviderResponseSDKType): MsgCreateStorageProviderResponse;
    toSDK(_: MsgCreateStorageProviderResponse): MsgCreateStorageProviderResponseSDKType;
};
export declare const MsgDeposit: {
    encode(message: MsgDeposit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeposit;
    fromJSON(object: any): MsgDeposit;
    toJSON(message: MsgDeposit): unknown;
    fromPartial<I extends {
        creator?: string;
        spAddress?: string;
        deposit?: {
            denom?: string;
            amount?: string;
        };
    } & {
        creator?: string;
        spAddress?: string;
        deposit?: {
            denom?: string;
            amount?: string;
        } & {
            denom?: string;
            amount?: string;
        } & Record<Exclude<keyof I["deposit"], keyof Coin>, never>;
    } & Record<Exclude<keyof I, keyof MsgDeposit>, never>>(object: I): MsgDeposit;
    fromSDK(object: MsgDepositSDKType): MsgDeposit;
    toSDK(message: MsgDeposit): MsgDepositSDKType;
};
export declare const MsgDepositResponse: {
    encode(_: MsgDepositResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDepositResponse;
    fromJSON(_: any): MsgDepositResponse;
    toJSON(_: MsgDepositResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDepositResponse;
    fromSDK(_: MsgDepositResponseSDKType): MsgDepositResponse;
    toSDK(_: MsgDepositResponse): MsgDepositResponseSDKType;
};
export declare const MsgEditStorageProvider: {
    encode(message: MsgEditStorageProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditStorageProvider;
    fromJSON(object: any): MsgEditStorageProvider;
    toJSON(message: MsgEditStorageProvider): unknown;
    fromPartial<I extends {
        spAddress?: string;
        endpoint?: string;
        description?: {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        };
        sealAddress?: string;
        approvalAddress?: string;
        gcAddress?: string;
        maintenanceAddress?: string;
        blsKey?: string;
        blsProof?: string;
    } & {
        spAddress?: string;
        endpoint?: string;
        description?: {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        } & {
            moniker?: string;
            identity?: string;
            website?: string;
            securityContact?: string;
            details?: string;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>;
        sealAddress?: string;
        approvalAddress?: string;
        gcAddress?: string;
        maintenanceAddress?: string;
        blsKey?: string;
        blsProof?: string;
    } & Record<Exclude<keyof I, keyof MsgEditStorageProvider>, never>>(object: I): MsgEditStorageProvider;
    fromSDK(object: MsgEditStorageProviderSDKType): MsgEditStorageProvider;
    toSDK(message: MsgEditStorageProvider): MsgEditStorageProviderSDKType;
};
export declare const MsgEditStorageProviderResponse: {
    encode(_: MsgEditStorageProviderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditStorageProviderResponse;
    fromJSON(_: any): MsgEditStorageProviderResponse;
    toJSON(_: MsgEditStorageProviderResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgEditStorageProviderResponse;
    fromSDK(_: MsgEditStorageProviderResponseSDKType): MsgEditStorageProviderResponse;
    toSDK(_: MsgEditStorageProviderResponse): MsgEditStorageProviderResponseSDKType;
};
export declare const MsgUpdateSpStoragePrice: {
    encode(message: MsgUpdateSpStoragePrice, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateSpStoragePrice;
    fromJSON(object: any): MsgUpdateSpStoragePrice;
    toJSON(message: MsgUpdateSpStoragePrice): unknown;
    fromPartial<I extends {
        spAddress?: string;
        readPrice?: string;
        freeReadQuota?: string | number | Long.Long;
        storePrice?: string;
    } & {
        spAddress?: string;
        readPrice?: string;
        freeReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["freeReadQuota"], keyof Long.Long>, never>);
        storePrice?: string;
    } & Record<Exclude<keyof I, keyof MsgUpdateSpStoragePrice>, never>>(object: I): MsgUpdateSpStoragePrice;
    fromSDK(object: MsgUpdateSpStoragePriceSDKType): MsgUpdateSpStoragePrice;
    toSDK(message: MsgUpdateSpStoragePrice): MsgUpdateSpStoragePriceSDKType;
};
export declare const MsgUpdateSpStoragePriceResponse: {
    encode(_: MsgUpdateSpStoragePriceResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateSpStoragePriceResponse;
    fromJSON(_: any): MsgUpdateSpStoragePriceResponse;
    toJSON(_: MsgUpdateSpStoragePriceResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateSpStoragePriceResponse;
    fromSDK(_: MsgUpdateSpStoragePriceResponseSDKType): MsgUpdateSpStoragePriceResponse;
    toSDK(_: MsgUpdateSpStoragePriceResponse): MsgUpdateSpStoragePriceResponseSDKType;
};
export declare const MsgUpdateParams: {
    encode(message: MsgUpdateParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams;
    fromJSON(object: any): MsgUpdateParams;
    toJSON(message: MsgUpdateParams): unknown;
    fromPartial<I extends {
        authority?: string;
        params?: {
            depositDenom?: string;
            minDeposit?: string;
            secondarySpStorePriceRatio?: string;
            numOfHistoricalBlocksForMaintenanceRecords?: string | number | Long.Long;
            maintenanceDurationQuota?: string | number | Long.Long;
            numOfLockupBlocksForMaintenance?: string | number | Long.Long;
            updateGlobalPriceInterval?: string | number | Long.Long;
            updatePriceDisallowedDays?: number;
        };
    } & {
        authority?: string;
        params?: {
            depositDenom?: string;
            minDeposit?: string;
            secondarySpStorePriceRatio?: string;
            numOfHistoricalBlocksForMaintenanceRecords?: string | number | Long.Long;
            maintenanceDurationQuota?: string | number | Long.Long;
            numOfLockupBlocksForMaintenance?: string | number | Long.Long;
            updateGlobalPriceInterval?: string | number | Long.Long;
            updatePriceDisallowedDays?: number;
        } & {
            depositDenom?: string;
            minDeposit?: string;
            secondarySpStorePriceRatio?: string;
            numOfHistoricalBlocksForMaintenanceRecords?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["numOfHistoricalBlocksForMaintenanceRecords"], keyof Long.Long>, never>);
            maintenanceDurationQuota?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maintenanceDurationQuota"], keyof Long.Long>, never>);
            numOfLockupBlocksForMaintenance?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["numOfLockupBlocksForMaintenance"], keyof Long.Long>, never>);
            updateGlobalPriceInterval?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["updateGlobalPriceInterval"], keyof Long.Long>, never>);
            updatePriceDisallowedDays?: number;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, keyof MsgUpdateParams>, never>>(object: I): MsgUpdateParams;
    fromSDK(object: MsgUpdateParamsSDKType): MsgUpdateParams;
    toSDK(message: MsgUpdateParams): MsgUpdateParamsSDKType;
};
export declare const MsgUpdateParamsResponse: {
    encode(_: MsgUpdateParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParamsResponse;
    fromJSON(_: any): MsgUpdateParamsResponse;
    toJSON(_: MsgUpdateParamsResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateParamsResponse;
    fromSDK(_: MsgUpdateParamsResponseSDKType): MsgUpdateParamsResponse;
    toSDK(_: MsgUpdateParamsResponse): MsgUpdateParamsResponseSDKType;
};
export declare const MsgUpdateStorageProviderStatus: {
    encode(message: MsgUpdateStorageProviderStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateStorageProviderStatus;
    fromJSON(object: any): MsgUpdateStorageProviderStatus;
    toJSON(message: MsgUpdateStorageProviderStatus): unknown;
    fromPartial<I extends {
        spAddress?: string;
        status?: Status;
        duration?: string | number | Long.Long;
    } & {
        spAddress?: string;
        status?: Status;
        duration?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["duration"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, keyof MsgUpdateStorageProviderStatus>, never>>(object: I): MsgUpdateStorageProviderStatus;
    fromSDK(object: MsgUpdateStorageProviderStatusSDKType): MsgUpdateStorageProviderStatus;
    toSDK(message: MsgUpdateStorageProviderStatus): MsgUpdateStorageProviderStatusSDKType;
};
export declare const MsgUpdateStorageProviderStatusResponse: {
    encode(_: MsgUpdateStorageProviderStatusResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateStorageProviderStatusResponse;
    fromJSON(_: any): MsgUpdateStorageProviderStatusResponse;
    toJSON(_: MsgUpdateStorageProviderStatusResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateStorageProviderStatusResponse;
    fromSDK(_: MsgUpdateStorageProviderStatusResponseSDKType): MsgUpdateStorageProviderStatusResponse;
    toSDK(_: MsgUpdateStorageProviderStatusResponse): MsgUpdateStorageProviderStatusResponseSDKType;
};
/** Msg defines the Msg service for creating a new storage provider.
 TODO: add a transaction that the Storage Provide claim themself enter short time maintenance to avoid slash */
export interface Msg {
    CreateStorageProvider(request: MsgCreateStorageProvider): Promise<MsgCreateStorageProviderResponse>;
    Deposit(request: MsgDeposit): Promise<MsgDepositResponse>;
    EditStorageProvider(request: MsgEditStorageProvider): Promise<MsgEditStorageProviderResponse>;
    UpdateSpStoragePrice(request: MsgUpdateSpStoragePrice): Promise<MsgUpdateSpStoragePriceResponse>;
    UpdateSpStatus(request: MsgUpdateStorageProviderStatus): Promise<MsgUpdateStorageProviderStatusResponse>;
    /**
     * UpdateParams defines a governance operation for updating the x/sp module parameters.
     * The authority is defined in the keeper.
     *
     * Since: cosmos-sdk 0.47
     */
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}
export declare class MsgClientImpl implements Msg {
    private readonly rpc;
    constructor(rpc: Rpc);
    CreateStorageProvider(request: MsgCreateStorageProvider): Promise<MsgCreateStorageProviderResponse>;
    Deposit(request: MsgDeposit): Promise<MsgDepositResponse>;
    EditStorageProvider(request: MsgEditStorageProvider): Promise<MsgEditStorageProviderResponse>;
    UpdateSpStoragePrice(request: MsgUpdateSpStoragePrice): Promise<MsgUpdateSpStoragePriceResponse>;
    UpdateSpStatus(request: MsgUpdateStorageProviderStatus): Promise<MsgUpdateStorageProviderStatusResponse>;
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}
